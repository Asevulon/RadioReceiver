
/*
Есть источник, нужно написать детектор.
У обнаружителя есть события обнаружения и параметры.
Параметры по которым он взводится и параметры (in, out: уровень) по которым он записывает события.
Например на каком уровне он обнаружил. Для начала реализуем обнаружение по уровню и
проверим его с источником, чтобы потом с аналогичным интерфейсом
можно было добавлять более сложные.
*/

/*
Идея:
Дрон облетает по какой-то траектории и в какой-то момент срабатывает детектор
и сохранит событие. Потом он вылетит из зоны приёма (уровень упадёт до маленького значения)
он инициирует событие, что покинул зону - это мининум.
Далее можно сделать так: с тех пор как он что-то обнаружил можно в нескольких местах
зафиксировать уровень и дальше в предположении, что он вещает одинаково можно считать что
этот уровень он характеризует расстояние (чем ближе подлетаемтем мощнее вещает, чем
дальше тем он тише) и если в интервале между обнаружением и пропаданием будет несколько точек,
то из этих точек можно провести некие круги обратнопропорцианальные уровню и в точке их
пересечения находится источник. То есть не только вход и выход (для интервала), но и ещё
несколько (1 сек.) точек посередине (временной интервал для событий). Также с какой частотой фиксировать присутствие сигнала.
Но должны знать где летим: полётный план, камера, координаты.
*/

/*
Что будет общим, что разным:
В родительский класс записать всё кроме обработки, интерфейсы для установки начальных
параметров приёма, интерфейсы для запуска. Есть класс детектора мы создаём его экземпляр
у него есть функция virtual detected(), и на вход подаём сигнал принятый, есть другие экземпляры с таким
же интерфейсом то тоже можно применить. И так для массива из таких объектов разного типа.
И из можно интерфейса загружать detected() подавая сигнал, а он будет обрабатывать. Можно сделать
на callback'ах. Можно сихнронно вызвать detected и он сразу отвечает, на вход указатель на
структуру с параметрами обнаружения. Но у каждого детектора будут свои критерии,
то есть уровень общим у всех считать нельзя.

Общее: передача сигнала, происходят события.
Разное: параметры события.

Асиинхронный детектор: детектор работает и время от времени скармливаем ему сигнал.

Приёмник и детектор разделяем, т.к. приёмник один на всех (слушает эфир).
Если тишина, то возможно надо подтянуть усиление.
*/

// date,      time,        hz_low,   hz_high, hz_bin_width, I,     Q
// 2018-12-03, 22:25:45, 2400000000, 2405000000, 1000000.00, 1.9, -0.2
#include <stdint.h>
#include <vector>

enum DetecterResult
{
    ok = 0
};

class Detecter
{
private:
protected:
    std::vector<double> data;
    int LastResult = 0;

public:
    virtual void ProcessData() = 0;
    void SetData(std::vector<double> &val);
    std::vector<double> GetData();
    int GetLastResult();
    Detecter() {};
    ~Detecter() {};
};

/*
Определяет наличие помехи по уровню энергии сигнала.
*/
class SignalEnergyDetecter : public Detecter
{
private:
    double Threshold = 0;

protected:
    double CalcEnergy(std::vector<double> &source);

public:
    void SetThreshold(double val);
    virtual void ProcessData();
};